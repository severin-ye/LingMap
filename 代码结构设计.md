根据你的偏好，我为《凡人修仙传因果图谱系统》基于R2框架设计了**详细的微服务代码结构与模块实现框架**，满足以下特性：

* 微服务架构（每个功能域独立服务）
* 每个服务内部采用“模块划分 + 分层设计”
* 使用依赖注入 + 抽象基类定义清晰接口
* JSON 配置 + ThreadPoolExecutor 异步处理
* 可插拔的Annoy向量检索

---

# 🏗️ 顶层目录结构（项目根目录）

```
r2-fanren/                      # 项目根目录
├── services/                   # 微服务集合目录
│   ├── text_ingestion/         # 文本摄入服务：将TXT转换为标准化章节JSON
│   ├── event_extraction/       # 事件抽取服务：提取关键事件、人物、宝物等
│   ├── hallucination_refine/   # 幻觉修正服务：使用HAR精修LLM输出
│   ├── causal_linking/         # 因果关联服务：分析事件间因果关系
│   ├── graph_builder/          # 图谱构建服务：生成可视化图谱代码
│   └── api_gateway/            # API网关服务：统一接口入口
├── common/                     # 共享组件目录
│   ├── models/                 # 领域模型定义：核心数据结构
│   ├── schemas/                # 数据验证架构：请求和响应验证
│   ├── interfaces/             # 抽象接口定义：统一接口规范
│   ├── config/                 # 配置管理：配置加载工具
│   └── utils/                  # 通用工具函数：日志、序列化等
├── scripts/                    # 辅助脚本：部署、打包和维护
├── configs/                    # 配置文件：JSON配置、提示模板等
├── tests/                      # 测试目录：单元测试和集成测试
└── README.md                   # 项目说明文档
```

---

# 🧩 每个微服务结构规范（以 `event_extraction` 为例）

```
event_extraction/
├── app.py                    # FastAPI 入口或 Worker 脚本
├── controller/               # 外部接口层（API 调用 / CLI 接口）
│   └── extractor_controller.py
├── service/                  # 业务逻辑层
│   └── extractor_service.py
├── repository/               # 数据源或外部模块访问（LLM调用）
│   └── llm_client.py
├── domain/                   # 领域模型与抽象接口
│   ├── base_extractor.py     # ABC 接口
│   └── models.py             # 数据结构
├── di/                       # 依赖注入容器
│   └── provider.py
└── config.json
```

---

# 🧱 核心服务设计清单

| 服务名称                   | 主要职责             | 输出类型               |
| ---------------------- | ---------------- | ------------------ |
| `text_ingestion`       | 加载txt小说→标准章节JSON | `List[Chapter]`    |
| `event_extraction`     | 抽取事件、宝物、人物等结构    | `List[EventItem]`  |
| `hallucination_refine` | 使用HAR精修LLM输出     | `List[EventItem]`  |
| `causal_linking`       | 构建事件对及其因果强度      | `List[CausalEdge]` |
| `graph_builder`        | 构建Mermaid格式图谱代码  | `str`              |
| `api_gateway`          | 整合所有服务为统一CLI/API | `REST / CLI`       |

---

# 📦 抽象接口（举例）

`common/interfaces/extractor.py`

```python
from abc import ABC, abstractmethod
from typing import List
from common.models.event import EventItem
from common.models.chapter import Chapter

class AbstractExtractor(ABC):
    @abstractmethod
    def extract(self, chapter: Chapter) -> List[EventItem]:
        pass
```

---

# 🧠 构造函数注入 + 服务注册（依赖注入）

`event_extraction/di/provider.py`

```python
from common.interfaces.extractor import AbstractExtractor
from event_extraction.service.extractor_service import EventExtractor

def provide_extractor() -> AbstractExtractor:
    return EventExtractor(model="gpt-4o", prompt_path="configs/prompt_event.json")
```

---

# 🔁 并发执行结构（例如事件批处理）

```python
from concurrent.futures import ThreadPoolExecutor
from event_extraction.service.extractor_service import EventExtractor

executor = ThreadPoolExecutor(max_workers=5)

results = list(executor.map(lambda ch: extractor.extract(ch), chapter_list))
```

---

# 🧩 JSON 配置文件示例（event\_extraction/config.json）

```json
{
  "model": "gpt-4o",
  "temperature": 0.0,
  "prompt_template": "./configs/prompt_event.json",
  "max_chunk_length": 1024
}
```

---

# 🧲 向量索引模块结构（Annoy）

```
common/vector_store/
├── annoy_indexer.py
├── encoder.py
└── interface.py
```

```python
class AnnoyIndexer(AbstractIndexer):
    def build_index(self, items: List[str]) -> None:
        ...
    def query(self, query: str, top_k: int = 5) -> List[str]:
        ...
```

---

# 📈 GraphBuilder 输出格式（Mermaid）

`graph_builder/service/graph_builder.py`

```python
def build_mermaid(events: List[EventItem], links: List[CausalEdge]) -> str:
    nodes = "\n".join([f'{e.event_id}[{e.description}]' for e in events])
    edges = "\n".join([f'{link.from_id} --> {link.to_id}' for link in links])
    return f"graph TD\n{nodes}\n{edges}"
```

---

# 🧪 测试与验证

```
tests/
├── test_event_extraction.py
├── test_refine_module.py
├── test_causal_linking.py
└── test_graph_output.py
```

使用 `pytest`，通过依赖注入的 mock provider 测试业务逻辑，确保服务独立性。

---

# 🚀 启动与调用

* 各服务可通过 `python app.py` 启动本地微服务/脚本
* `api_gateway` 提供统一入口支持 REST 接口或 CLI 流程：

```bash
python api_gateway/main.py --input "fanren.txt" --output "out/graph.mmd"
```

---

